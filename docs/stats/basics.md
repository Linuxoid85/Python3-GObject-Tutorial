# Основы

В этом разделе приведены общие сведения о GTK+.

## Главный цикл и сигналы

Как и большинство наборов инструментов с графическим пользовтаельским интерфейсом, GTK+ использует модель программирования, управляемую событиями. Когда пользователь ничего не делает, GTK+ сидит в основном цикле и ждёт ввода. Если пользователь совершает какое-либо действие - скажем, целчок мышью - тогда основной цикл "просыпается" и доставляет событие в GTK+.

Когда виджеты получают событие, они чатсо отсылают один или несколько сигналов. Они уведомляют программу о том, что что-то произошло, вызывая функции, которые вы подключили к сигналу. Такие функции обычно называются *обратными вызовами* (callback). Когда вызываются ваши обратные вызовы, вы обычно предпринимаете какое-то действие - например, при нажатии кнопки "Открыть" вы можете отобразить диалоговое окно выбора файла (*а лучше сделать другое окно для выбора файла и вызвать его взамен оригинального - прим. переводчика*). После завершения обратного вызова GTK+ вернётся в основной цикл и будет ожидать дополнительных действий пользователя.

Общий пример:

```python
handler_id = widget.connect("event", callback, data)
```

Во-первых, *виджет* (widget) - это экземпляр созданного ранее виджета. Далее событие (`event`), которое нас интересует. У каждого виджета есть свои собственные события, которые могут произойти. Например, если у вас есть кнопка, вы обычно хотите подключиться к событию `clicked`. Это означает, что при нажатии кнопки выдаётся сигнал.

Во-вторых, аргумент `callback` - это имя функции обратного вызова. Он содержит код, который запускается при выдаче сигналов указанного типа.

Наконец, аргумент `data` включает любые данные, которые должны быть переданы при выдаче сигнала. Однако этот аргумент является необязательным и может быть опущен, если не требуется.

Функция возвращает число, которое идентифицирует эту конкретную пару *сигнал*--*обратный вызов*. Требуется отключиться от сигнала, чтобы функция обратного вызова не вызывалась во время каких-либо будущих или текущих выдач сигнала, к которому она была подключена.

```python
widget.disconnect(handler_id)
```

Если вы по какой-то причине потеряли "<tt>handler_id</tt>" (например, обработчики были установлены с помощью `Gtk.Builder.connect_signals()`), вы всё равно можете отключить определённый обратный вызов с помощью функции `disconnect_by_func()`:

```python
widget.disconnect_by_func(callback)
```

Приложения должны подключаться к сигналу "destroy" окна верхнего уровня. Обработчик по умолчанию уничтожает окно, но не завершит работу приложения. Подключение сигнала "destroy" окна верхнего уровня к функции `Gtk.main_quit()` приведёт к желаемому поведению.

```python
window.connect("destroy", Gtk.main_quit)
```

Вызов `Gtk.main-quit()` приводит к возврату основного цикла внутри `Gtk.main()`.

## Характеристики (свойства)

Свойства описывают конфигурацию и состояние виджетов. Что касается сигналов, каждый виджет имеет свой набор свойств. Например, кнопка имеет свойство "label", которое содержит текст виджета метки внутри кнопки. Вы можете указать имя и значение любого кол-ва свойств в качестве аргументов ключевого слова при создании экземпляра виджета. Чтобы создать метку, выровненную по правому краю, с текстом "Hello World" и углом 25॰, используйте:

```python
label = Gtk.Label(label="Hello World", angle=25, halign=Gtk.Align.END)
```

Эта строка эквивалентна следующему:

```python
label = Gtk.Label()
label.set_label("Hello World")
label.set_angle(25)
label.set_halign(Gtk.Align.END)
```

Вместо использования геттеров и сеттеров вы так же можете получать и устанавливать свойства `gobject` через св-во "props", такое как `widget.props.prop_name = value`. Это эквивалентно более подробным `widget.get_property("имя свойства")` и `widget.set_property("имя свойства", значение)`.

To see which properties are available for a widget in the running version of GTK you can “dir” the “props” property:

```python
widget = Gtk.Box()
print(dir(widget.props))
```

Это напечатает в консоли список свойств `Gtk.Box`.
